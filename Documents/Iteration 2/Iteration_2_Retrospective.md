# Iteration 2 Retrospective

After iteration 1 we had discussed all of the things that had worked for our group and all of the things that didn’t work. One of our issues was not sticking to dev tasks or having many of them change as we built up the app, from our original vision. This is not a huge issue as we are using an agile workflow but it definitely meant that we have room to improve in regards to planning. Now we are setting less of a rigid set of dev tasks and having some being created on the go, with our initial dev tasks set out as a blueprint. 

For iteration 2 we had originally wanted to have a way for multiple users to make requests for items for the main user to accept or decline. Whilst this feature stayed mostly the same there were difficulties with storing data created by the requests i.e. boolean values, etc. Thus we made a pivot to have the request list accepted by a multiple select in the GUI, which helped us avoid storing excessive data. Decisions like this were able to be executed because we bought in to an adaptable structure so we were able to modify our flow and direction. 

We had also discussed sticking to GitLab flow which we found worked a lot better. We were always able to have a working version of our app with the newest commits working together. It was definitely much cleaner than the previous Git Flow, with less branches in total, and this created less confusion for which branches were the working branches and which were old garbage branches. With this strategy we also agreed to push finished individual branches once we had our applicable tests completed for the feature, so we didn’t have to worry about writing tests at the end. This also resulted in less merges to the main branch which made it easier to track where we were and which merges were being accepted. The image in this [link](https://code.cs.umanitoba.ca/comp3350-winter2024/lethalcompany-a01-13/-/blob/main/Documents/Iteration%202/Iteration%202%20GitLab%20Flow%20Example.png) shows one of our group members creating a branch, and merging it back once they are done.

Our features were a lot more content heavy in this iteration than iteration 1 which led to some underestimating regarding time estimates (evidence can be found in this [link](https://code.cs.umanitoba.ca/comp3350-winter2024/lethalcompany-a01-13/-/blob/main/Documents/Iteration%203/Project_Velocity__by_iteration_.png?ref_type=heads)). We used the time tracking feature which helped to give us a better idea of how long we need, but with some unanticipated setbacks in a couple of the features we were working on, it created some excess work that we were not ready for. In the end it got done, and now we have an idea of how to handle estimating time for features that we don't exactly know how to approach.

Lastly in iteration there was an issue with work distribution, amongst the members, this iteration we looked to make improvements on this, while there was an attempt to make the work more equally dispersed there was still an uneven amount of work done and not done by the group members. This will be something that we will have to talk about heavily for iteration 3 and make a correction to it.
